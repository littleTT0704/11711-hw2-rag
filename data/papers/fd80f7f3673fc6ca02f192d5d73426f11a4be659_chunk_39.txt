(r[’severity’]) and len(r[’span’]) == len(r[’category’]),
13 axis=1
14 ).all():
15 return False
16
17 # Check if there are at least min_errors
18 if examples[’severity’].apply(lambda svs: len(svs)).sum() < min_errors:
19 return False
20
21 # Check that there’s a balance of major and minor errors.
22 major_count = examples[’severity’].apply(lambda svs: sum([s==’major’ for s in svs])).sum()
23 minor_count = examples[’severity’].apply(lambda svs: sum([s==’minor’ for s in svs])).sum()
24 if abs(major_count - minor_count) > majmin_threshold:
25 return False
26
27 # Check that at least cat_diversity error types are represented.
28 categories = examples[’category’].apply(lambda cs: [c.split("/")[0] for c in cs])
29 represented_error_types = set().union(*categories.tolist())
30 if len(represented_error_types) < cat_diversity:
31 return False
32
33 top_clen = examples.apply(
34 lambda row: max(len(row[s]) for s in (’source’, ’reference’, ’candidate’)
35 ), axis=1).max()
36 bot_clen = examples.apply(
37 lambda row: min(len(row[s]) for s in (’source’, ’reference’, ’candidate’)),
38 axis=1).min()
39
40 if top_clen > max_clen or bot_clen < min_clen:
41 return False
42
43 # All checks passed.
44 return True
Figure11: Rejectioncriteriausedwhensamplingin-contextlearningexamplesfor AUTOMQM.
0.45 0.45
PaLM-2 (Bison) ref-based PaLM-2 (Bison