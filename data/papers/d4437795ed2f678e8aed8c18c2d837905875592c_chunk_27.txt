To illustrate the computing power required, consider sentence analyzers available today
that typically operate at 1-100 sentences per minute (on a 10 MIPS4 workstation), with the range
reflecting the degree to which they explore alternative hypotheses and make use of complex
7
semantic constraints. At this rate, a 10 sentence corpus (such as is now becoming available)
5 7
would require 10 to 10 minutes (2 to 200 months) to parse. For meaningful iterations in
parse/semantic analysis, the iteration cycle needs to less than 10 minutes, implying a speed-up
of 102 to 104 (1 to 100 GIPS4).
November 23,1992 23
In addition to the need for higher computational power, the architectural needs also differ
for different basic research topics addressed. These requirements may be better served by a
hybrid system containing general-purpose as well as special-purpose computers. In the rest of
this section, we discuss these requirements.
1) General-purpose supercomputing — more cycles, more memory, more bandwidth. Many
symbolic computations required for SNLP do not have the specialized regular structure that
would justify special-purpose architectures. These computations simply require a substantial
amount of computing power and will best be served by general-purpose parallel computer sys­
tems. For instance, many aspects of language analysis can be formulated as search tasks and can
be carried out in parallel computers. In addition, for analyses of large corpora, much of the pro­
cessing can be done independently on individual sentences and can be executed with minimal
communication overhead in a general-purpose parallel system.
2) Homogeneous architectures. While large problems in SNLP are inherently heterogene­
ous, homogeneity within large subtasks can be exploited. For instance, many tasks can be
expressed as matrix and vector operations that can be executed efficiently on parallel and vector
architectures. Attempts have also been made to unify the multiple aspects of SNLP using homo­
geneous architectures. Connectionist models are good examples for providing a consistent
representation at all levels, where activation variables may be viewed as a particularly simple
form of message (a single low-precision number). Although actual implementations may require
elements that are not of this form, to the extent that they are connectionist, both software and
hardware can be greatly simplified and still be quite flexible.
3) Special-