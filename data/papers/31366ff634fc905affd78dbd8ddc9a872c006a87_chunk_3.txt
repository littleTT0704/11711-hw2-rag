ra
Reference:
int f(Object target) {
int i = 0;
for (Object elem: this.elements) {
if (elem.equals(target)) {
return i;
}
i++;
}
return -1;
}
(a)Thegroundtruthreference–findtheindexoftargetinthis.elements.
Non-equivalentcandidate: Equivalentcandidate:
boolean f(Object target) { int f(Object target) {
for (Object elem: this.elements) { for (int i=0; i<this.elements.size(); i++) {
if (elem.equals(target)) { Object elem = this.elements.get(i);
return true; if (elem.equals(target)) {
} return i;
} }
}
return false; return -1;
} }
(b) Preferred by BLEU & CrystalBLEU – find (c) Preferred by CodeBERTScore – find the index of target in
whetherornottargetisinthis.elements. this.elements.
Figure 1: An intuitive example for the usefulness of CodeBERTScore in measuring generated code: Figure 1(a)
shows a reference code snippet in Java. Figure 1(b) and Figure 1(c) show two generated predictions. Among
these two candidates and given the reference, both BLEU and CrystalBLEU prefer (score higher) the snippet in
Figure1(b),whichisnotfunctionallyequivalenttothereference,whileourproposedCodeBERTScoreprefersthe
codeinFigure1(c),whichisfunctionallyequivalenttothecodeinFigure1(a).
mer, but accepting them may lead to partial code et al., 2020). First, CodeBERTScore encodes
that doesnot parse, andthus cannot befully eval- the generated code and the reference code inde-
uated by CodeBLEU (for example, predicting the pendently with pretrained models, with the inclu-
firstlineofaforloop,withouttheloop’sbody). sionofnaturallanguageinstructionsorcomments.
Execution-basedevaluationattemptstoaddress Then, we compute the cosine similarity between
these problems by running tests on the generated the encoded representations